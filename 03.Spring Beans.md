![SpringFramework drawio](https://github.com/user-attachments/assets/4eb93857-5da1-45f1-8aec-dd65b018d995)

---

## In this step, we will create Spring Beans using Java Configuration

In traditional Java applications, we’re responsible for manually creating and managing objects and their dependencies using `new`. This tightly couples classes and makes them harder to test and maintain.

But with **Spring Framework**, we can use a **Spring Application Context** to manage object creation and wiring for us. These managed objects are known as **Beans**.

Let’s walk through how to do this using **Java-based configuration** .

![loc drawio](https://github.com/user-attachments/assets/32b6b24b-6a5d-4ad5-b514-6c91efa21ddd)

---

### Step 1: Launching the Spring Context

We begin by creating a **Spring Application Context**. This context will read a configuration class (`@Configuration`) and initialize the necessary beans.


```java
public class BasicGamingApp {
    public static void main(String[] args) {
        // Launch a Spring Context
        var context =
                new AnnotationConfigApplicationContext(GameConfiguration.class);
    }
}
```

Here:

* We use `AnnotationConfigApplicationContext`, which is a Spring container designed for Java-based configuration.
* It reads the class `GameConfiguration` to discover the beans defined using `@Bean` methods.

---

### Step 2: Define the Beans (Objects Managed by Spring)

Now let’s define the beans we want Spring to manage. These are regular Java objects — the only difference is that Spring will create and wire them.

```java
@Configuration
public class GameConfiguration {

    @Bean
    public GamingConsole game() {
        return new PacManGame(); // Change this to MarioGame or SuperContraGame easily
    }

    @Bean
    public GameRunner gameRunner(GamingConsole game) {
        return new GameRunner(game);
    }
}
```
Here:

* `@Configuration` tells Spring that this class will provide bean definitions.
* `@Bean` marks methods whose return values should be managed as beans.
* Spring sees the `gameRunner()` method and notices it requires a `GamingConsole` object — it automatically injects the result of `game()` into it.

So in this setup:

* `game()` creates and returns an instance of `PacManGame`.
* `gameRunner(game)` receives that instance and returns a `GameRunner`.

This is called **Constructor Injection**, one of the most common dependency injection methods in Spring.

---

### Step 3: Retrieve and Use the Beans

Once the context is created, we can retrieve and use the beans managed by Spring:

```java
public class BasicGamingApp {
    public static void main(String[] args) {

        // Launch a Spring Context
        var context =
                new AnnotationConfigApplicationContext(GameConfiguration.class);

        // Retrieve and use the GameRunner bean
        context.getBean(GameRunner.class).run();
    }
}
```

* Here, we tell Spring: “Give me the `GameRunner` bean you created.”
* Spring returns the `GameRunner` with its `GamingConsole` dependency already injected.
* We then call the `run()` method on it — and the game starts.

---

## How to list all beans managed by Spring Container?

We can list all beans managed by Spring Container using the following code:

``` java

public class BasicGamingApp {
    public static void main(String[] args) {

        // Launch a Spring Context
        var context =
                new AnnotationConfigApplicationContext(GameConfiguration.class);
   
        Arrays.stream(context.getBeanDefinitionNames()).forEach(System.out::println);
    }
}

```
### output
    org.springframework.context.annotation.internalConfigurationAnnotationProcessor
    org.springframework.context.annotation.internalAutowiredAnnotationProcessor
    org.springframework.context.annotation.internalCommonAnnotationProcessor
    org.springframework.context.event.internalEventListenerProcessor
    org.springframework.context.event.internalEventListenerFactory
    gameConfiguration
    game
    gameRunner

--- 

## What if multiple matching beans are found?


In **Spring**, if **multiple matching beans** are found when the framework tries to inject a dependency — and you haven't told it which one to choose — **Spring will throw an error**

---

### Example Scenario

Let's say you have:

```java
@Bean
public GamingConsole marioGame() {
    return new MarioGame();
}

@Bean
public GamingConsole pacManGame() {
    return new PacManGame();
}
```

Now Spring has **two beans of type `GamingConsole`**.

If you do:

```java
@Bean
public GameRunner gameRunner(GamingConsole game) {
    return new GameRunner(game);
}
```

Spring won’t know which `GamingConsole` to inject — so it throws an error.

---

### How to Fix It

#### Option 1: Use `@Primary` to mark a default bean

```java
@Bean
@Primary
public GamingConsole marioGame() {
    return new MarioGame();
}
```

Now Spring will choose `marioGame()` when there's ambiguity.

---

#### Option 2: Use `@Qualifier` to specify which one you want

```java
@Bean
public GameRunner gameRunner(@Qualifier("pacManGame") GamingConsole game) {
    return new GameRunner(game);
}
```

---

## Primary vs Qualifier

**@Primary annotation** is used to specify the default bean to be used when multiple beans are available.

**@Qualifier** annotation is used to specify the bean to be used when multiple beans are available.


---

## Design Game Runner to run games (Mario, SuperContra,Pacman etc)

### Tight Coupling vs Loose Coupling

* **Tight coupling** = Class A directly creates and depends on Class B, making it hard to test, extend, or modify without breaking things.

* **Loose coupling** means that classes **know as little as possible about each other**. They **depend on abstractions** (interfaces), not concrete implementations.

In the example below, GameRunner class has a dependency on GamingConsole. Instead of wiring game object to a specific class such as MarioGame, we can use GamingConsole interface to make it loosely coupled. So that, we don't need to change our original code. In the future, we can create classes that implements GamingConsole interface (Polymorphism) and use it.

---
 
### Iteration 1: Tightly Coupled Java Code

* GameRunner class
* Game classes: Mario, SuperContra, Pacman etc

![tightCouplingFinal drawio](https://github.com/user-attachments/assets/eab1162e-bc4b-47b9-ae3d-00e6a1407c87)



``` java
public class MarioGame {
    public void run(){
        System.out.println("Mario Game Running...");
    }
}

public class PacManGame {
    public void run() {
        System.out.println("PacMan Game Running...");
    }
}

public class SuperContraGame{
    public void run(){
        System.out.println("SuperContraGame is Running...");
    }
}

public class GameRunner {
    private MarioGame game; // Tightly coupled to a specific game, so we need to change this.

    public GameRunner(MarioGame game) {
        this.game = game;
    }

    public void start() {
        game.run();
    }
}

public class BasicGamingApp {
    public static void main(String[] args) {
        PacManGame pacman = new PacManGame();
        SuperContraGame superContraGame = new SuperContraGame();
        MarioGame marioGame = new MarioGame();
        GameRunner gameRunner = new GameRunner(marioGame);
        gameRunner.start();
    }
}

```

---

###  Iteration 2: Loose Coupling - Interfaces
 * GameRunner class
 * GamingConsole interface
 * Game classes: Mario, SuperContra, Pacman etc 

![lastLooseCoupling drawio](https://github.com/user-attachments/assets/a5bb24d4-2134-4cdb-ad79-a7a5f8009b63)


``` java

public interface GamingConsole {
    void run();
}

public class GameRunner {
    private final GamingConsole game; // Loosely coupled, it's not a specific game anymore.
                                      // Games implement GamingConsole interface.

    GameRunner(GamingConsole game) {  // game dependency is injected via constructor
        this.game = game;
    }

    public void run() {
        game.run();
    }
}

public class BasicGamingApp {
    public static void main(String[] args) {
        // PacManGame game = new PacManGame();
        // SuperContraGame game = new SuperContraGame();

        MarioGame game = new MarioGame(); // object creation
        GameRunner gameRunner = new GameRunner(game); // wiring dependencies
        // Game is dependency of GameRunner
        gameRunner.start();
    }
}

```


---

Right now, the creation of the objects is completely managed by us.

These objects are created in the JVM, Java Virtual Machine, and the code to create these objects
and wire them together is written by us.

![jvm drawio](https://github.com/user-attachments/assets/00d4076d-262d-4b0c-ac55-1216e27eb3af)

We want the Spring Framework to handle all of thisâ€”creating the objects and wiring them together for us

![jvmSpring drawio](https://github.com/user-attachments/assets/d3b684a6-ddb5-4ca2-b533-7657e6288c7b)


